---
layout: posts
title: "Chapter Four: "
date: 2020-10-29
---  

So far, we've got software running on the system that allows us to use a console to input and output data. While this is all fine and dandy, our underlying uart device driver used to read from the console does so by polling. This involves the driver code checking if the recieve buffer is not empty every time it wants to read. This scheme is not a very efficient use of system resources - particularly when the system in question supports interrupts.  

### The whys and hows  

An interrupt is a alert -from the hardware - that needs attention from the software. For instance, when we type anything on the console, the processor is alerted of this event so that it can be handled in a timely manner. This may require the current flow of control/execution to be interrupted - hence the name. Since they can occur at any time, interrupts (at least hardware interrupts) are asynchronous.  How the interrupts are handled depends on interrupt handling/exception handling model of the processor.  

Let's go back to chapter 2 where we identified that the first 240 bytes of code represent the **interrupt vector table** with each entry pointing to an interrupt handler or interrupt service routine - the software fucntion that handles a particular interrupt. The ARM Cortex-M3 and the Nested Vectored Interrupt Controller (NVIC) prioritize and handle all of these interrupts - called exceptions in the Cortex-M3 world. When an exception is triggered, the processor state -  represented by it's registers - is automatically pushed to the stack and restored from the stack once the exception handling is complete - that is when the ISR exits.  

The interrupt can be enabled and prioritised using the SFRs of the NVIC. For now, since we'll be dealing with the interrupt generated when data is receieved by the UART device, we won't bother with priority. By the way, we have already dealt with exception handling in chapter 2, which is how we setup our ```data/bss``` segments and got to ```main()``` in the first place. This was done by invoking the handler to the ```Reset``` exception - whose address was made available at location ```0x00000004```.  The exception is triggered on power-up or warm-reset. There are 9 other such exceptions and 59 interrupts (IRQs) generated by peripherals. Other than the ```Reset```, ```Hard Fault``` and ```Non-Maskable Interrupt```, all other interrupts have programmable priorities.

The details regarding the features of the NVIC are available in section 2.5 of the data sheet.  

### Interrupt-driven UART  

If we look at table 2-9 on the data sheet, we see that vector number ```21``` refers to UART0 - i.e. an interrupt generated by the peripheral ```UART0```. There can be several conditions which result in an interrupt generated by the UART. As discussed in the beginning, we want to improve the our UART driver - by reading data from the recieve buffer only when it is available - with the use of interrupts.  

How do we go about setting up generating, receiving and handling this interrupt?  

Since the UART0 is the device that generates the interrupt, our task would be to ensure that the device does so when a certain condition is met, which in our case is on recieving data. This can be done with the aid of some SFRs meant for this purpose. If you look at section 12.3.6, you'll see that what we need to do to get the UART to generate an interrupt on recieving data are:  

1. Enable the bit in the ```UARTIM``` (UART Interrupt Mask) register corresponding to the Recieve Interrupt so that it can be routed to the interrupt controller.
2. Use ```UARTRIS```(UART Raw Interrupt Status) or ```UARTMIS```(UART Maskes Interrupt Status) register to monitor the status of the interrupts. 
3. Clear the bit corresponding to the Recieve interrupt in the ```UARTICR``` (UART Interrupt Clear) register when we're done handling the interrupt.  

If you've noticed the register descriptions, the ```UARTMIS/UARTRIS``` and ```UARTICR``` look identical, a property we will leverage when finding out what interrupt is triggered and clear it appropriately, once handled. 

To this end, we'll define these registers within our ```uart_regs``` structures to reside at teh appropriate offset and perform the above tasks with a set of functions as follows:  

```C  

/* Enable the said uart interface to generate interrupts
 * depending on the flag set - conditions for interrupt generation.
 * This interrupt is then sent to the interrupt controller.
 */
static void uart_irq_enable(uint32_t irq_flags)
{
    uart0->IM |= irq_flags;
}

/* Clear the interrupt for said uart interface
 * depending on the flag set.
 */
static void uart_irq_clear(uint32_t irq_flags)
{
    uart0->ICR = irq_flags;
}

/* Get the current interrupt status of the said uart interface
 * depending of whether is_masked is true or false, it returns
 * the masked or raw interrupt status.
 */
static uint32_t uart_irq_status(bool is_masked)
{
    if(is_masked)
        return (uart0->MIS);
    else
        return (uart0->RIS);
}  

```
Notice how these functions are defined generically to set/monitor/clear any of the UART interrupts supported. This allows for our driver to be scaled to accomodate more interrupts should the need arise. Now, enabling the interrupt is done when we init the uart device before we actually turn it on so that any data received at any time from the point of the device being turned on triggers an interrupt.  

It's not enough to have the interrupt generated by the device. This interrupt has to be routed through the interrupt controller to the processor so that the control of execution can then be handed to the interrupt handler/vector/ISR which will be use to process the interrupt. By enabling the recieve interrupt bit in ```UARTIM```, we've ensure that an interrupt generated by the device when it recieves data is routed to the interrupt controller. Our next step should be to ensure that the interrupt controller "informs" the processor of this. For this, we'll need to look at the SFRs of the ```NVIC``` (Nested Vectored Interrupt Controller).  

A detailed description of the ```NVIC``` is available in section 3.1.2. Let's go to the SFRs and see what we can do to get our UART interrupt through to the processor via ```NVIC```.  

Section 3.4 details the register descriptions of the various ```NVIC``` registers. 

